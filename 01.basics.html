<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<title>Loading React | React.js Reference</title>
	<link rel="stylesheet" href="css/styles.css">
</head>
<body>


<h2>Loading React on an existing website</h2>
<ol>
	<li>Load <code>react</code> and <code>react-dom</code> from the <code>unpkg.com</code> CDN</li>
	<li>For development mode, load the <code>.development</code> versions</li>
	<li>For production mode, load the <code>.production.min</code> versions</li>
	<li>You can also load <code>babel</code> from the same CDN to be able to use modern JS (use this only on dev, for production use JS pre-processors)</li>
</ol>
<!-- -->
<script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"></script>
<script crossorigin src="https://unpkg.com/babel-standalone@6/babel.min.js"></script>


<h2>Rendering a React element</h2>
<ul>
	<li>Use <code>React.createElement</code> to define and create React elements with the arguments
		<ol>
			<li>tag name, e.g. <code>p</code></li>
			<li>properties object
				<ul>
					<li><code>key</code> is an internal ID to keep track of elements, it's not rendered on the markup</li>
					<li>Event handlers (e.g. <code>onClick</code>)</li>
					<li>Everything else is rendered as HTML attributes, even if they are not standard attributes</li>
					<li>To add the <code>class</code> attribute, you need to use <code>className</code> instead to prevent conflicts with the reserved js keyword</li>
				</ul>
			</li>
			<li>child elements
				<ul>
					<li>You can pass a string for a simple child text node, or a React element</li>
					<li>For multiple children, pass an array with strings or React elements</li>
					<li>Each child element needs to have a unique <code>key</code> prop, so React can easily keep track of them and update them whenever necessary</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>Use <code>ReactDOM.render</code> to render a React element on the DOM
		<ol>
			<li>React element to be displayed
				<ul>
					<li>You can only pass one root element, so if you need to render multiple elements you'll have to create a container element and then add all the the elements you want as children</li>
					<li>If you don't want the extra markup generated by a container element, you can use the special <code>React.Fragment</code> component as placeholder, it won't display any markup leaving the child elements at the top-level</li>
				</ul>
			</li>
			<li>DOM node to use as container (will remove all child elements and replace them with the React element)</li>
		</ol>
	</li>
</ul>
<!-- -->
<div id="my-app" class="component"></div>
<script>
(function(){
	ReactDOM.render(
		React.createElement(React.Fragment, {}, [
			'Hello World!',
			React.createElement(
				'p',
				{
					key: 'time-of-day',
					id: 'my-id',
					'non-standard-attr': 'asad',
					onClick: () => alert('hi!')
				},
				'The time is '+new Date().toLocaleTimeString()
			)
		]),
		document.querySelector('#my-app')
	);
})();
</script>


<h2>Defining React components</h2>
<p>React components are elements with more advanced functionality, like handling passed data, managing an internal state, triggering events, etcâ€¦</p>
<p>There's 2 ways of defining components:</p>
<ol>
	<li>As <code>functions</code>:
		<ul>
			<li>The <code>props</code> object will be passed as the first argument</li>
			<li>Needs to return a <code>React.createElement</code></li>
		</ul>
	</li>
	<li>As <code>classes</code>:
		<ul>
			<li>The class needs to extend the <code>React.Component</code> class</li>
			<li>The <code>props</code> object will be passed as the first argument of the <code>constructor</code> function</li>
			<li>It needs to have a <code>render</code> method, which will return the final <code>React.createElement</code> to be displayed</li>
		</ul>
	</li>
</ol>
<!-- -->
<div id="my-app-2" class="component"></div>
<script>
(function(){
	function ComponentFunction(props) {
		return React.createElement('p', {}, 'Component defined as a function!');
	}
	class ComponentClass extends React.Component {
		render() {
			return React.createElement('p', {}, 'Component defined as a class!');
		}
	}
	ReactDOM.render(
		React.createElement(React.Fragment, {}, [
			React.createElement(ComponentFunction, {key: 'component-1'}),
			React.createElement(ComponentClass, {key: 'component-2'})
		]),
		document.querySelector('#my-app-2')
	);
})();
</script>


<h3>Component <code>props</code></h3>
<ul>
	<li>On components, the <code>props</code> object is passed as-is (excluding the <code>key</code> property)</li>
	<li>It's up to the component to decide what HTML attributes to output, props are not automatically converted to attributes and event handlers like in simple elements</li>
</ul>
<h3>Component <code>state</code></h3>
<ul>
	<li>The <code>state</code> object holds the internal data related to the component instance, whenever it changes the component gets re-rendered to reflect those changes</li>
	<li>The state can only be set directly with <code>this.state</code> on the constructor method, everywhere else it needs to be updated with <code>this.setState()</code></li>
	<li><code>this.setState()</code> accepts a simple object, only the included properties will be updated, missing properties will be kept on the state as they are</li>
	<li>If you need to calculate the new data based on the current state data, then instead of passing an object, pass a function that receives the current state as the first argument, and return the object with the updated state properties, e.g. <code>this.setState((state, props) => ({counter: state.counter+1}))</code>. This is to ensure you're getting the most up to date version of the state, sometimes there may be pending async changes not yet reflected on <code>this.state</code></li>
	<li>To access <code>this.state</code> and <code>this.setState</code> inside custom class methods, you'll need to bind <code>this</code> to them in the constructor</li>
</ul>
<!-- -->
<div id="my-app-3" class="component"></div>
<script>
(function(){
	class ComponentClass extends React.Component {
		constructor(props) {
			super(props);
			this.state = {counter: 0};
			// enable 'this' on methods
			this.increment = this.increment.bind(this);
		}
		increment() {
			// this.setState({ counter: 10 })							// no need to read current state: pass object
			this.setState(state => ({counter: state.counter+1}))		// has to read current state: pass function
		}
		render() {
			return React.createElement('p', {}, [
				'Dynamic content. props: '+this.props.name+', state: '+this.state.counter+' ',
				React.createElement('button', {key: 'increment-button', onClick: this.increment}, 'Increment')
			]);
		}
	}
	ReactDOM.render(
		React.createElement(ComponentClass, {name: 'Jeff'}),
		document.querySelector('#my-app-3')
	);
})();
</script>


</body>
</html>
